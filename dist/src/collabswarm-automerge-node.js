"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AutomergeSwarmNode = exports.DEFAULT_NODE_CONFIG = void 0;
const collabswarm_automerge_1 = require("./collabswarm-automerge");
const collabswarm_automerge_config_1 = require("./collabswarm-automerge-config");
const fs = __importStar(require("fs"));
exports.DEFAULT_NODE_CONFIG = {
    ipfs: {
        relay: {
            enabled: true,
            hop: {
                enabled: true // enable circuit relay HOP (make this node a relay)
            }
        },
        config: {
            Addresses: {
                Swarm: [
                    '/ip4/0.0.0.0/tcp/4003/ws',
                    '/ip4/0.0.0.0/tcp/4001',
                    '/ip6/::/tcp/4002'
                ]
            },
            Bootstrap: [],
        }
    },
    pubsubDocumentPrefix: '/document/',
    pubsubDocumentPublishPath: '/documents'
};
class AutomergeSwarmNode {
    constructor(config = exports.DEFAULT_NODE_CONFIG) {
        this.config = config;
        this._swarm = new collabswarm_automerge_1.AutomergeSwarm();
        this._subscriptions = new Map();
        this._seenCids = new Set();
        this._docPublishHandler = null;
    }
    get swarm() {
        return this._swarm;
    }
    // Start
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.swarm.initialize(this.config);
            // console.log('Node Addresses:', this.swarm.ipfsInfo.addresses);
            const websocketAddress = this.swarm.ipfsInfo.addresses.find((address) => address.toString().includes('/ws/'));
            const clientConfig = JSON.parse(JSON.stringify(collabswarm_automerge_config_1.DEFAULT_CONFIG));
            if (websocketAddress) {
                clientConfig.ipfs.config.Bootstrap.push(websocketAddress);
            }
            // TODO: Make this automatically generated by webrtc-star-signal (and integrate that into this).
            const starSignalAddress = '/ip4/127.0.0.1/tcp/9090/wss/p2p-webrtc-star';
            if (starSignalAddress) {
                clientConfig.ipfs.config.Addresses.Swarm.push(starSignalAddress);
            }
            const clientConfigFile = process.env.REACT_APP_CLIENT_CONFIG_FILE || 'client-config.env';
            fs.writeFile(clientConfigFile, `REACT_APP_CLIENT_CONFIG='${JSON.stringify(clientConfig)}'`, (err) => {
                if (err) {
                    console.error(`Failed to write ${clientConfigFile}:`, err);
                }
                else {
                    console.log(`Wrote ${clientConfigFile}:`, clientConfig);
                }
            });
            // Open a pubsub channel (set by some config) for controlling this swarm of listeners.
            // TODO: Add a '/document/<id>' prefix to all "normal" document paths.
            this._docPublishHandler = (rawMessage) => {
                try {
                    const thisNodeId = this.swarm.ipfsInfo.id.toString();
                    const senderNodeId = rawMessage.from;
                    if (thisNodeId !== senderNodeId) {
                        const message = JSON.parse(rawMessage.data.toString());
                        console.log('Received Document Publish message:', rawMessage);
                        const docRef = this.swarm.doc(message.documentId);
                        if (docRef) {
                            // Also add a subscription that pins new received files.
                            this._subscriptions.set(message.documentId, docRef);
                            docRef.subscribe('pinning-handler', (doc, hashes) => {
                                for (const cid of hashes) {
                                    if (!this._seenCids.has(cid)) {
                                        // TODO: Handle this operation failing (retry).
                                        this.swarm.ipfsNode.pin.add(cid);
                                        this._seenCids.add(cid);
                                    }
                                }
                            });
                            // Listen to the file.
                            docRef.open();
                            // Pin all of the files that were received.
                            for (const cid of Object.keys(message.changes)) {
                                if (!this._seenCids.has(cid)) {
                                    // TODO: Handle this operation failing (retry).
                                    this.swarm.ipfsNode.pin.add(cid);
                                    this._seenCids.add(cid);
                                }
                            }
                        }
                        else {
                            console.warn('Failed to process incoming document pin message:', rawMessage);
                            console.warn('Unable to load document', message.documentId);
                        }
                    }
                    else {
                        console.log('Skipping publish message from this node...');
                    }
                }
                catch (err) {
                    console.error('Failed to process incoming document pin message:', rawMessage);
                    console.error('Error:', err);
                }
            };
            yield this.swarm.ipfsNode.pubsub.subscribe(this.config.pubsubDocumentPublishPath, this._docPublishHandler);
            console.log(`Listening for pinning requests on: ${this.config.pubsubDocumentPublishPath}`);
        });
    }
    stop() {
        if (this._docPublishHandler) {
            this.swarm.ipfsNode.pubsub.unsubscribe(this.config.pubsubDocumentPublishPath, this._docPublishHandler);
        }
        if (this._subscriptions) {
            for (const [id, ref] of this._subscriptions) {
                ref.unsubscribe('pinning-handler');
            }
        }
    }
}
exports.AutomergeSwarmNode = AutomergeSwarmNode;
//# sourceMappingURL=collabswarm-automerge-node.js.map